# Обзор проекта Auto Dock

## Обзор
Auto Dock - это инструмент, который автоматически генерирует документацию для проектов на Python. Он сканирует указанный корневой каталог проекта, извлекает код и создает описания для каждого файла, используя языковые модели, чтобы предоставить более детализированную и качественную документацию.

## Особенности
- **Многоязычность**: Поддержка нескольких языков, включая английский, русский, украинский, китайский, испанский и польский.
- **Обработка файловой системы**: Возможность игнорирования определенных файлов и каталогов во время сканирования проекта.
- **Генерация подсказок**: Автоматическая генерация текстовых подсказок для языковых моделей на основе кода проекта.
- **Интеграция с AI**: Использование языковых моделей для формирования ответов и документации.
- **Прогресс и управление временем**: Простая визуализация процесса работы и управление временем выполнения различных методов.

## Структура
Основные компоненты проекта включают:
- `config.py`: Настройки конфигурации, включая поддержку языков.
- `main.py`: Основной файл для выполнения проекта. Содержит основную логику и взаимодействие с API.
- `providers_test.py`: Тестирование провайдеров AI для проверки их работоспособности.
- `requirements.txt`: Указание зависимостей проекта.
- `utilities.py`: Утилиты для управления временем и отображения прогресса.

## Использование
Чтобы использовать Auto Dock, необходимо выполнить следующие шаги:
1. Установить зависимости из файла `requirements.txt`.
2. Запустите `main.py`, указав необходимые параметры через командную строку: имя проекта, корневой путь, файлы для игнорирования и язык.
3. Проект автоматически сгенерирует документацию в виде файла `README.md`, который будет создан в указанной директории.
# Документация использования модуля `./config.py`

Данный модуль предоставляет функционал для генерации запросов на языках, указанных в словаре `language_type`. Он включает класс `GenerateLanguagePrompt`, который отвечает за создание структурированных текстов на разных языках. Ниже описаны используемые методы класса и их назначение.

## Использование

1. Импортируйте модуль.
2. Создайте экземпляр класса `GenerateLanguagePrompt`, передав ему словарь `language_type`.
3. Вызовите метод `generate()` для получения словаря с готовыми текстовыми запросами на всех языках.

## Методы

### `__init__(self, languages: dict[str, int]) -> None`

Конструктор класса. Инициализирует объект `GenerateLanguagePrompt`.

**Параметры:**

- `languages` (dict[str, int]): Словарь языков, где ключ
# Документация к файлу `main.py`

## Использование

Данный проект предназначен для автоматической генерации документации на основе кода, находящегося в заданной директории. Использует модели генерации текста для создания описаний к проекту.

### Классы и методы

#### `ReqHendler`

Класс `ReqHendler` отвечает за обработку запросов, связанных с получением и хранением кода из файлов.

- **`__init__(self, root_dir: str, language: str = "en", ignore_file: list[str] = None, project_name: str = "Python Project") -> None`**
  - Конструктор класса. Инициализирует параметры, включая корневую директорию, язык, игнорируемые файлы и имя проекта.

- **`get_files_from_directory(self, current_path: str = "") -> None`**
  - Рекурсивно получает все файлы из заданной директории, добавляя их в список `all_files`, за исключением игнорируемых.

- **`is_ignored(self, path: str) -> bool`**
  - Проверяет, находится ли указанный путь к файлу в списке игнорируемых файлов.

- **`get_code_from_file(self) -> None`**
  - Читает содержимое каждого файла из списка `all_files` и сохраняет его в словаре `codes`, где ключ — путь к файлу, а значение — его содержимое.

- **`make_prompt(self) -> str`**
  - Создаёт строку, которая будет использоваться в запросе к модели, включает название проекта и содержимое всех файлов.

#### `GptHandler`

Класс `GptHandler` управляет взаимодействием с моделью генерации текста.

- **`__init__(self, provider: str = "DarkAI") -> None`**
  - Конструктор класса. Инициализирует обработчик на основе указанного провайдера.

- **`get_answer(self, prompt: str) -> str`**
  - Отправляет запрос к модели на основе переданного `prompt` и возвращает полученный ответ.

#### `AnswerHandler`

Класс `AnswerHandler` управляет ответами от генеративной модели.

- **`__init__(self, answer: str) -> None`**
  - Конструктор класса. Инициализирует список ответов.

- **`save_documentation(self, name: str = "README.md") -> None`**
  - Сохраняет полученные ответы в файл с заданным именем.

- **`combine_response(self, new_response: str) -> None`**
  - Добавляет новый ответ к уже существующим.

- **`make_start_req_form(cls, prompt: str) -> list`**
  - Создаёт начальную структуру запроса для передачи в модель.

#### `AutoDock`

Класс `AutoDock` запускает процесс генерации документации.

- **`__init__(self, root_dir: str, language: str = "en", ignore_file: list[str] = None, project_name: str = "Python Project") -> None`**
  - Конструктор класса. Инициализирует процесс, собрав код из заданной директории.

- **`get_response(self, codes: dict) -> AnswerHandler`**
  - Получает ответы от генеративной модели для каждого файла и комбинирует их в один ответ.

- **`time_control(self, prompt, answer_handler)`**
  - Управляет временем ожидания между запросами, чтобы избежать превышения лимитов.

- **`get_part_of_response(self, prompt: str, answer_handler: AnswerHandler = None) -> AnswerHandler`**
  - Отправляет запрос к модели и обрабатывает ответ. Если передан `answer_handler`, комбинация ответов будет обновлена.

- **`save_dock(self, answer_handler: AnswerHandler, name: str = "Readme_files/README") -> None`**
  - Сохраняет финальный ответ в файл с указанием языка.

## Пример использования

Запустите скрипт с параметрами командной строки для указания имени проекта, корневой директории, файлов для игнорирования и языков:

```bash
python main.py --name_project "Мой проект" --root_dir "/путь/к/проекту" --ignore "['игнорируемый_файл.py']" --languages "['en', 'ru']"
```

Это запустит процесс и создаст документацию для файлов в указанной директории, игнорируя указанные файлы.
# Документация по использованию скрипта `./providers_test.py`

Данный скрипт предназначен для тестирования провайдеров чатов с использованием API библиотеки `g4f` в Python. В этом разделе описываются основные методы и их использование.

## Классы и методы

### Класс `TextStyle`

Этот класс отвечает за стилизацию текста для вывода в консоль.

#### Методы

- **`__init__(self) -> None`**
  
  Инициализация стиля текста. 

- **`get_text(self, text: str, color: any = "", back: any = "") -> str`**
  
  Генерирует текст с заданными цветами переднего плана (color) и фона (back).

  **Аргументы:**
  - `text`: строка текста, который будет отображен.
  - `color`: цвет переднего плана (по умолчанию пустая строка).
  - `back`: цвет фона (по умолчанию пустая строка).

  **Возвращает:**
  - Отформатированная строка с примененным стилем.

---

### Класс `ProgressBar`

Этот класс визуализирует процесс выполнения с помощью индикатора прогресса.

#### Методы

- **`__init__(self, part) -> None`**
  
  Инициализация индикатора прогресса.

  **Аргументы:**
  - `part`: общее количество шагов для отображения прогресса.

- **`progress(self, name)`**
  
  Обновляет вывод индикатора прогресса.

  **Аргументы:**
  - `name`: название текущего провайдера, отображаемое в индикаторе прогресса.

---

### Класс `ProviderTest`

Этот класс управляет тестированием различных провайдеров API.

#### Методы

- **`__init__(self, model_name: str) -> None`**
  
  Инициализация с заданным именем модели.

  **Аргументы:**
  - `model_name`: имя модели, которую необходимо протестировать.

- **`get_providers(self)`**
  
  Получает список провайдеров, доступных в `g4f.Provider`.

- **`test_provioder(self, provider_name: str) -> tuple[bool, str]`**
  
  Тестирует указанный провайдер.

  **Аргументы:**
  - `provider_name`: имя провайдера для тестирования.

  **Возвращает:**
  - Кортеж: первый элемент - логическое значение, указывающее на успешность, второй элемент - ответ от провайдера (или `None`, если произошла ошибка).

- **`test_provider_timeout(self, provider)`**
  
  Тестирует провайдер с установленным ограничением по времени.

  **Аргументы:**
  - `provider`: провайдер, который должен быть протестирован.

  **Возвращает:**
  - Ответ от API или `None`, если произошла ошибка.

- **`test_providers(self)`**
  
  Тестирует все провайдеры и выводит результаты.

  **Возвращает:**
  - Словарь с именами работающих провайдеров и их ответами.

---

### Использование

В результате выполнения этого скрипта будет произведено тестирование всех доступных провайдеров с использованием заданной модели. Необходимо запускать скрипт из командной строки и предоставлять аргумент `--name_model` для указания имени модели, например:

```bash
python providers_test.py --name_model gpt-4
```

После этого скрипт выведет результаты тестирования всех доступных провайдеров, которые смогли успешно обработать запрос.
# Документация по использованию методов

Этот файл содержит укороченную документацию по методам в вашем проекте. Для полной документации обратитесь к основным файлам проекта. 

## Методы

### Метод 1: `method_one()`

Описание: Этот метод выполняет основную функцию, связанную с обработкой данных.

**Параметры:**

- `param1` (тип): Описание параметра 1.
- `param2` (тип): Описание параметра 2.

**Возвращаемое значение:**
- (тип): Описание возвращаемого значения.

---

### Метод 2: `method_two()`

Описание: Данный метод отвечает за осуществление определенных вычислений и возвращает результат.

**Параметры:**

- `param` (тип): Описание параметра.

**Возвращаемое значение:**
- (тип): Результат вычислений.

---

### Метод 3: `method_three()`

Описание: Этот метод предоставляет функционал для работы с внешними API.

**Параметры:**

- `url` (str): URL, к которому будет осуществлен запрос.
- `headers` (dict): Заголовки для HTTP-запроса.

**Возвращаемое значение:**
- (тип): Ответ от API.

---

### Метод 4: `method_four()`

Описание: Метод, который обрабатывает ошибки и исключения.

**Параметры:**

- `error` (Exception): Исключение, которое нужно обработать.

**Возвращаемое значение:**
- (str): Описание ошибки.

---

Эта документация предназначена для упрощения использования методов вашего проекта. Для дополнительной информации или примеров использования, обратитесь к основному коду.
# Документация по использованию `./utilities.py`

Этот модуль предоставляет утилиты для отображения прогресс-баров и стилизации текста в консольном приложении. Ниже описаны методы и классы, доступные в этом файле.

## Классы

### TextStyle

`TextStyle` — класс для стилизации текста.

#### Методы

- `__init__(self) -> None`
  
  Конструктор класса, инициализирует модуль `colorama`.

- `get_text(self, text: str, color: any = "", back: any = "") -> str`
  
  Метод для получения стилизованного текста.
  
  **Аргументы:**
  - `text` (str): текст, который нужно стилизовать.
  - `color` (any): цвет текста (по умолчанию пустая строка).
  - `back` (any): цвет фона текста (по умолчанию пустая строка).
  
  **Возвращает:**
  - (str): Стилизованный текст.

### ProgressBar

`ProgressBar` — класс для отображения прогресс-бара.

#### Методы

- `__init__(self, part) -> None`
  
  Конструктор класса, инициализирует переменные для прогресс-бара.
  
  **Аргументы:**
  - `part`: количество частей для расчета прогресса.

- `progress(self, name)`
  
  Метод для обновления и отображения прогресс-бара.
  
  **Аргументы:**
  - `name`: строка, представляющая имя операции, прогресс которой отображается.

## Функции

### start(part)

Инициализирует объект `ProgressBar` с указанным количеством частей.

**Аргументы:**
- `part`: количество частей для прогресс-бара.

### time_manager(func)

Декоратор для функции, который измеряет время выполнения функции и отображает прогресс с помощью `ProgressBar`.

**Аргументы:**
- `func`: функция, время выполнения которой требуется замерить.

**Возвращает:**
- Обернутую функцию, которая отображает прогресс и время выполнения.
