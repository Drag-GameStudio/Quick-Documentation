# Auto Dock

## Огляд
Auto Dock — це інструмент для автоматичного створення документації проектів на Python. Він аналізує код, генерує підказки для написання документації та підтримує кілька мов. З його допомогою можна зекономити час на підготовку документації і забезпечити її якість.

## Особливості
- Підтримує кілька мов, включаючи англійську, російську, українську, китайську, іспанську та польську.
- Автоматичне виявлення файлів у заданій директорії з можливістю ігнорування певних файлів.
- Генерація документації у форматі Markdown за допомогою моделі GPT-4.
- Вбудовані механізми для обробки запитів та управління часом виконання.

## Структура
Проект складається з кількох основних компонентів:
- **config.py**: файл конфігурації, в якому визначено доступні мови та основні налаштування програми.
- **main.py**: основний модуль програми, що реалізує логіку отримання коду та генерації документації.
- **utilities.py**: утиліти для управління стилями тексту, відображення прогресу й вимірювання часу виконання функцій.
- **providers_test.py**: модуль для тестування доступних постачальників (провайдерів) GPT.
- **requirements.txt**: файл, що містить залежності проекту.

## Використання
Щоб скористатися Auto Dock, потрібно виконати наступні кроки:
1. Встановити залежності з `requirements.txt`.
2. Запустити `main.py`, передавши необхідні аргументи (назва проекту, коренева директорія, файли для ігнорування та мови, в яких потрібно згенерувати документацію).
3. Програма автоматично сканує код, генерує документацію і зберігає її у вказаній директорії.
# Документація для файлу `./config.py`

## Використання

Цей файл містить класи та змінні, які дозволяють генерувати підказки для документації на різних мовах. Основний клас, `GenerateLanguagePrompt`, відповідає за створення підказок для документації на основі зазначених мов.

### Методи

#### `__init__(self, languages: dict[str, int]) -> None`

Конструктор класу `GenerateLanguagePrompt`. 

**Аргументи:**
- `languages`: Словник, в якому ключами є назви мов (строки), а значеннями - їх індекси (цілі числа).

**Опис:**
Конструктор ініціалізує екземпляр класу, зберігаючи доступні мови в атрибуті `self.languages`, перетворюючи ключі словника в список.

#### `generate(self) -> dict`

Генерує словник підказок для кожної мови.

**Повертає:**
- `language_prompt`: Словник, в якому ключами є індекси мов, а значеннями - списки підказок для кожної з мов.

**Опис:**
Цей метод перебирає всі доступні мови та викликає метод `gen_prompt` для генерації підказки для кожної мови.

#### `gen_prompt(self, language: str) -> list[str]`

Генерує підказку для зазначеної мови.

**Аргументи:**
- `language`: Назва мови (строка), для якої потрібно згенерувати підказку.

**Повертає:**
- `BASE_PROMPT`: Список з двох рядків, що містять підказки для документації.

**Опис:**
Метод створює базову підказку, яка включає інформацію про форматування документації (Markdown) та специфікації, такі як необхідні секції для опису проекту. 

## Наприкінці примітки

Використання класу `GenerateLanguagePrompt` дозволяє оптимізувати процес створення документації на різних мовах, гарантуючи, що структура буде єдиною і відповідатиме вимогам Google Style.
# Документація до `./main.py`

## Використання

Цей файл реалізує автоматизовану генерацію документації для Python проектів. Він використовує API для генерації текстових відповідей і виконує обробку виходу з файлів проекту.

### Клас `ReqHendler`

#### `__init__(self, root_dir: str, language: str = "en", ignore_file: list[str] = None, project_name: str = "Python Project") -> None`
Конструктор класу `ReqHendler`. Ініціалізує об'єкт із заданими параметрами.

- **Parameters:**
  - `root_dir` (str): Кореневий каталог проекту.
  - `language` (str): Мова документації.
  - `ignore_file` (list[str]): Список файлів, які потрібно ігнорувати.
  - `project_name` (str): Назва проекту.

#### `get_files_from_directory(self, current_path: str = "") -> None`
Збирає всі файли з заданого каталогу, рекурсивно скануючи підкаталоги.

- **Parameters:**
  - `current_path` (str): Шлях до поточного підкаталогу (необов'язково, за замовчуванням - порожній).

#### `is_ignored(self, path: str) -> bool`
Перевіряє, чи повинен бути проігнорований файл за заданим шляхом.

- **Parameters:**
  - `path` (str): Шлях до файлу.
- **Returns:**
  - bool: `True`, якщо файл проігноровано; в іншому випадку - `False`.

#### `get_code_from_file(self) -> None`
Збирає код з усіх файлів проекту у словник.

### Клас `GptHandler`

#### `__init__(self, provider: str = "DarkAI") -> None`
Конструктор класу `GptHandler`. Ініціалізує об'єкт з обраним провайдером.

- **Parameters:**
  - `provider` (str): Назва провайдера для запиту.

#### `get_answer(self, prompt: str) -> str`
Відправляє запит до GPT і повертає відповідь.

- **Parameters:**
  - `prompt` (str): Повідомлення для генерації.
- **Returns:**
  - str: Відповідь від GPT.

### Клас `AnswerHandler`

#### `__init__(self, answer: str) -> None`
Конструктор класу `AnswerHandler`.

- **Parameters:**
  - `answer` (str): Відповідь для збереження.

#### `save_documentation(self, name: str = "README.md") -> None`
Зберігає документацію у файл.

- **Parameters:**
  - `name` (str): Назва файлу для збереження.

#### `combine_response(self, new_response: str) -> None`
Додає нову відповідь до наявних.

- **Parameters:**
  - `new_response` (str): Нова відповідь для додавання.

#### `make_start_req_form(cls, prompt: str) -> list`
Створює форму запиту.

- **Parameters:**
  - `prompt` (str): Повідомлення для запиту.
- **Returns:**
  - list: Список повідомлень для запиту.

### Клас `AutoDock`

#### `__init__(self, root_dir: str, language: str = "en", ignore_file: list[str] = None, project_name: str = "Python Project") -> None`
Конструктор класу `AutoDock`. Ініціалізує автоматичний документатор.

- **Parameters:**
  - `root_dir` (str): Кореневий каталог проекту.
  - `language` (str): Мова документації.
  - `ignore_file` (list[str]): Список файлів для ігнорування.
  - `project_name` (str): Назва проекту.

#### `get_response(self, codes: dict) -> AnswerHandler`
Отримує відповіді від GPT для всіх файлів проекту.

- **Parameters:**
  - `codes` (dict): Код з усіх файлів проекту.
- **Returns:**
  - AnswerHandler: Об'єкт `AnswerHandler` з відповідями.

#### `time_control(self, prompt, answer_handler)`
Контролює час між запитами для уникнення перевантаження.

- **Parameters:**
  - `prompt` (str): Повідомлення для запиту.
  - `answer_handler` (AnswerHandler): Об'єкт `AnswerHandler` для збереження відповідей.

#### `get_part_of_response(self, prompt: str, answer_handler: AnswerHandler = None) -> AnswerHandler`
Отримує частину відповіді на запит.

- **Parameters:**
  - `prompt` (str): Повідомлення для запиту.
  - `answer_handler` (AnswerHandler): Об'єкт `AnswerHandler` для об'єднання нових відповідей (необов'язково).
- **Returns:**
  - AnswerHandler: Об'єкт `AnswerHandler` з відповідями.

#### `save_dock(self, answer_handler: AnswerHandler, name: str = "Readme_files/README") -> None`
Зберігає сгенеровану документацію у файл.

- **Parameters:**
  - `answer_handler` (AnswerHandler): Об'єкт `AnswerHandler` з відповідями.
  - `name` (str): Назва файлу для збереження документації.

**Примітка:** Будь ласка, зверніть увагу, що методом збереження файлу є стандартний метод запису в режимі "додавання", що дозволяє накопичувати відповіді.
# Документація щодо використання файлу `providers_test.py`

Цей файл призначений для тестування різних провайдерів для моделі ChatGPT за допомогою бібліотеки `g4f`. Нижче наведено опис методів, які можна використовувати в цьому файлі.

## Метод `timeout_control(timeout)`

Цей метод є декоратором, який дозволяє керувати часом виконання функцій. Він запускає функцію в окремому потоці і повертає `None`, якщо функція не завершилася за вказаний час.

### Параметри
- `timeout`: Максимальний час у секундах, протягом якого функція повинна завершитися.

### Повертає
- Декоратор, що обгортає функцію з функціоналом таймаута.

## Клас `TextStyle`

Цей клас відповідає за стилізацію тексту.

### Метод `__init__()`

Ініціалізує кольори і стилі з бібліотеки `colorama`.

### Метод `get_text(text: str, color: any = "", back: any = "") -> str`

Цей метод повертає текстовий рядок із зазначеними кольором і фоновим кольором.

#### Параметри
- `text`: Текст, що підлягає форматуванню.
- `color`: Колір тексту (за замовчуванням - пустий).
- `back`: Фоновий колір (за замовчуванням - пустий).

#### Повертає
- Створений текстовий рядок з форматуванням.

## Клас `ProgressBar`

Цей клас для відстеження прогресу.

### Метод `__init__(self, part)`

Ініціалізує новий об'єкт прогрес бару.

#### Параметри
- `part`: Кількість частин, що відображаються в прогрес барі.

### Метод `progress(name)`

Цей метод оновлює прогрес бар, виводячи інформацію про прогрес.

#### Параметри
- `name`: Назва провайдера, що тестується.

## Клас `ProviderTest`

Цей клас використовується для тестування провайдерів ChatGPT.

### Метод `__init__(self, model_name: str)`

Ініціалізує новий об'єкт `ProviderTest`.

#### Параметри
- `model_name`: Ім'я моделі, яку тестують.

### Метод `get_providers()`

Цей метод отримує список доступних провайдерів з `g4f`.

### Метод `test_provioder(provider_name: str) -> tuple[bool, str]`

Цей метод тестує конкретний провайдер.

#### Параметри
- `provider_name`: Ім'я провайдера, який тестується.

#### Повертає
- кортеж з двох значень: булеве значення (успішність тесту) і відповідь провайдера.

### Метод `test_provider_timeout(self, provider)`

Цей метод тестує провайдер із таймаутом.

#### Параметри
- `provider`: Провайдер, який тестується.

#### Повертає
- Відповідь від провайдера або `None`, якщо сталася помилка або перевищений таймаут.

### Метод `test_providers()`

Цей метод тестує всі доступні провайдери і виводить результати.

#### Повертає
- Словник з іменами провайдерів та їх відповідями, якщо вони успішно пройшли тест.

## Використання

Для запуску цього файлу використовуйте команду:

```bash
python providers_test.py --name_model <ім'я_моделі>
```

Необхідно замінити `<ім'я_моделі>` на назву моделі, яку потрібно протестувати, наприклад, `gpt-4` або `gpt-3.5-turbo`. 

В результаті тестування буде виведено словник активних провайдерів разом із відповідями.
# Додаткова документація

Цей файл містить інформацію про використання методів, наданих у проекті, який має залежності `colorama` версії `0.4.6` та `g4f` версії `0.3.8.0`.

## Використання

### Метод `colorama.init()`

Ініціалізує модуль `colorama`, що дозволяє використовувати кольори в консолі.

#### Приклад:
```python
from colorama import init
init()
```

### Метод `colorama.Fore`

Цей метод надає функції для зміни кольору тексту в консольному виведенні.

#### Доступні кольори:
- `colorama.Fore.RED` - червоний текст
- `colorama.Fore.GREEN` - зелений текст
- `colorama.Fore.YELLOW` - жовтий текст
- `colorama.Fore.BLUE` - синій текст
- `colorama.Fore.MAGENTA` - пурпурний текст
- `colorama.Fore.CYAN` - блакитний текст
- `colorama.Fore.WHITE` - білий текст
- `colorama.Fore.RESET` - скидання до стандартного кольору

#### Приклад:
```python
from colorama import Fore

print(Fore.RED + 'Це червоний текст!' + Fore.RESET)
```

### Метод `g4f.query()`

Цей метод використовується для запитів до API в рамках проекту. Він дозволяє отримувати дані з зовнішніх джерел.

#### Параметри:
- `prompt` (str): текст запиту.
- `model` (str, необов'язковий): модель для виконання запиту, за замовчуванням використовується модель по замовченню.

#### Приклад:
```python
import g4f

response = g4f.query(prompt="Яка сьогодні погода?", model="GPT-3")
print(response)
```

### Метод `g4f.get_available_models()`

Цей метод повертає список доступних моделей, які можуть бути використані для запитів.

#### Повертає:
- `list`: список назв доступних моделей.

#### Приклад:
```python
available_models = g4f.get_available_models()
print("Доступні моделі:", available_models)
```

Ця документація надає базові відомості про методи використання в даному проекті. За детальнішою інформацією та прикладами, будь ласка, зверніться до основної документації проекту.
# Документація до файлу `utilities.py`

Цей файл містить корисні класи та функції для роботи з виводом тексту з кольорами та прогресом виконання.

## Використання

### Клас `TextStyle`

Клас `TextStyle` використовує бібліотеку `colorama` для стилизованого виводу тексту.

#### Методи

- `__init__(self) -> None`
  
  Ініціалізація класу. Ініціює `colorama`.

- `get_text(self, text: str, color: any = "", back: any = "") -> str`
  
  Форматує текст з вказаними кольором та фоном. Параметри:
  - `text`: Текст, який потрібно відобразити.
  - `color`: (необов'язковий) Кольоровий стиль тексту (використовує кольори з `colorama`).
  - `back`: (необов'язковий) Фоновий колір тексту (використовує кольори з `colorama`).
    
  Повертає відформатований рядок.

### Клас `ProgressBar`

Клас `ProgressBar` дозволяє відображати прогрес виконання, представлене у вигляді прогрес-бару.

#### Методи

- `__init__(self, part) -> None`
  
  Ініціалізує клас `ProgressBar`. Параметри:
  - `part`: Кількість частин, на які розбивається прогрес.

- `progress(self, name)`
  
  Оновлює та відображає прогрес-бар для вказаного процесу. Параметри:
  - `name`: Назва операції, яку потрібно відобразити в прогрес-барі.

### Глобальні функції

- `start(part)`

  Ініціалізує новий об'єкт `ProgressBar` з вказаною кількістю частин. Параметри:
  - `part`: Кількість частин прогресу.

- `time_manager(func)`

  Декоратор, який обгортає функцію, щоб виміряти та відобразити час її виконання. Використання:
  
  ```
  @time_manager
  def my_function():
      # Ваш код тут
  ```

  При виклику функції відобразить прогрес, який показує початок і кінець виконання з тривалістю в секундах.
